graph controller
  on load, call redraw manager on full set of entities
  when set of entities is moved, call redraw manager on that set

redraw manager (depends on entity pair service and attachment service)
  call entitiesAffectedByMove to get the entities of interest
  call pairsAffectedByMove to get the entity pairs of interest
  call clear() on the affected entities
  call refresh() on the affected entity pairs
  sort entity pairs by attachment priority (globally in the set)
  loop through entity pairs:
    call attachment service for each

attachment service:
  has a method that takes an entity pair as an argument, and attaches all the relationships in the pair as a group.
    EXCEPTION: reflexive relationships are drawn INDIVIDUALLY based on their control point (180, 270).
  these must be attached in a group to prevent the "crossover" bug in the previous implementation.
  this service does not care about attachment priority -- this is the responsibility of the redraw manager.
    look up each side, get vacancy ranges
    place (mutate) each relationship's actual endpoints
      if there is overlap that is big enough to fit all the relationships with straight lines, place them evenly spaced
      else place them at the ends closest to each other to minimize skew
    update each side's vacancy range based on the space occupied

side
  A simple space manager. Assumes space will be occupied from the ends (top and bottom) first.
  Instantiated with entity.
  clear() -- resets to blank state for fresh placement
  occupyBottom(upToPosition) -- accept a chunk of space at the bottom to be occupied (and recalculate vacancy)
  occupyTop(upToPosition)    -- accept a chunk of space at the top    to be occupied (and recalculate vacancy)
  vacancy -- the remaining space

entity pair service:
  entitiesAffectedByMove(entities) -- determine entities that may experience endpoint movement around their perimeter
